/* byte_ranges.hpp
Efficient small actor read-write lock
(C) 2016 Niall Douglas http://www.nedprod.com/
File Created: March 2016


Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef BOOST_AFIO_SHARED_FS_MUTEX_BYTE_RANGES_HPP
#define BOOST_AFIO_SHARED_FS_MUTEX_BYTE_RANGES_HPP

#include "../../file_handle.hpp"
#include "base.hpp"

BOOST_AFIO_V2_NAMESPACE_BEGIN

namespace algorithm
{
  namespace shared_fs_mutex
  {
    /*! \class byte_ranges
    \brief Many entity shared/exclusive file system based lock

    This is a simple many entity shared mutex. It works by locking in the same file the byte at the
    offset of the entity id. If it fails to lock a byte, it backs out all preceding locks, randomises the order
    and tries locking them again until success. Needless to say this algorithm puts a lot of strain on
    your byte range locking implementation, some NFS implementations have been known to fail to cope.

    - Compatible with networked file systems, though be cautious with older NFS.
    - Exponential complexity to number of entities being concurrently locked, though some OSs
    provide linear complexity so long as total concurrent waiters is one.
    - Optionally can sleep until a lock becomes free in a power-efficient manner.
    - Sudden process exit with lock held is recovered from.
    - Sudden power loss during use is recovered from.

    Caveats:
    - Byte range locks need to work properly on your system. Misconfiguring NFS or Samba
    to cause byte range locks to not work right will produce bad outcomes.
    - Multithreaded usage on the same lock file doesn't work on many POSIXs.
    */
    class byte_ranges : public shared_fs_mutex
    {
      file_handle _h;

      byte_ranges(file_handle &&h)
          : _h(std::move(h))
      {
      }
      byte_ranges(const byte_ranges &) = delete;
      byte_ranges &operator=(const byte_ranges &) = delete;

    public:
      //! The type of an entity id
      using entity_type = shared_fs_mutex::entity_type;
      //! The type of a sequence of entities
      using entities_type = shared_fs_mutex::entities_type;

      //! Move constructor
      byte_ranges(byte_ranges &&o) noexcept : _h(std::move(o._h)) {}
      //! Move assign
      byte_ranges &operator=(byte_ranges &&o) noexcept
      {
        _h = std::move(o._h);
        return *this;
      }

      //! Initialises a shared filing system mutex using the file at \em lockfile
      //[[bindlib::make_free]]
      static result<byte_ranges> fs_mutex_byte_ranges(file_handle::path_type lockfile) noexcept
      {
        BOOST_OUTCOME_FILTER_ERROR(ret, file_handle::file(std::move(lockfile), file_handle::mode::write, file_handle::creation::if_needed, file_handle::caching::temporary, file_handle::flag::delete_on_close));
        return byte_ranges(std::move(ret));
      }

      //! Return the handle to file being used for this lock
      const file_handle &handle() const noexcept { return _h; }

    protected:
      virtual result<void> _lock(entities_guard &out, deadline d) noexcept override final
      {
        stl11::chrono::steady_clock::time_point began_steady;
        stl11::chrono::system_clock::time_point end_utc;
        if(d)
        {
          if((d).steady)
            began_steady = stl11::chrono::steady_clock::now();
          else
            end_utc = (d).to_time_point();
        }
        size_t n;
        do
        {
          {
            auto undo = detail::Undoer([&] {
              for(; n != (size_t) -1; n--)
              {
                _h.unlock(out.entities[n].value, 1);
              }
            });
            for(n = 0; n < out.entities.size(); n++)
            {
              if(d)
              {
                if((d).steady)
                {
                  if(stl11::chrono::steady_clock::now() >= (began_steady + stl11::chrono::nanoseconds((d).nsecs)))
                    return make_errored_result<void>(ETIMEDOUT);
                }
                else
                {
                  if(stl11::chrono::system_clock::now() >= end_utc)
                    return make_errored_result<void>(ETIMEDOUT);
                }
              }
              deadline nd(std::chrono::seconds(0));
              BOOST_OUTCOME_FILTER_ERROR(guard, _h.lock(out.entities[n].value, 1, out.entities[n].exclusive, nd));
              if(!guard)
                goto failed;
            }
            undo.dismiss();
            continue;
          }
        failed:
          // Randomise out.entities
          std::random_shuffle(out.entities.begin(), out.entities.end());
          // Sleep for a very short time
          std::this_thread::yield();
        } while(n < out.entities.size());
        return make_result<void>();
      }

    public:
      virtual void unlock(entities_type entities) noexcept override final
      {
        for(const auto &i : entities)
        {
          _h.unlock(i.value, 1);
        }
      }
    };

  }  // namespace
}  // namespace

BOOST_AFIO_V2_NAMESPACE_END


#endif
