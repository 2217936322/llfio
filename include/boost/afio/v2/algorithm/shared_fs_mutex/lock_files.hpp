/* multiple_shared_lock.hpp
Efficient many actor read-write lock
(C) 2016 Niall Douglas http://www.nedprod.com/
File Created: March 2016


Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef BOOST_AFIO_MULTIPLE_SHARED_LOCK_HPP
#define BOOST_AFIO_MULTIPLE_SHARED_LOCK_HPP

#include "../file_handle.hpp"

BOOST_AFIO_V2_NAMESPACE_BEGIN

namespace algorithm
{
  /*! \class multiple_shared_lock
  \brief Efficient many actor shared/exclusive file system based lock

  Lock files scale poorly to the number of items being concurrently locked with typically an exponential
  drop off in performance as the number of items being concurrently locked rises. This file system
  algorithm solves this problem using IPC via a shared append-only lock file.

  - Compatible with networked file systems (NFS too if the special nfs_compatibility flag is true).
  - Invariant complexity to number of items being locked.
  - Linear complexity to number of processes concurrently using the lock (i.e. number of waiters).

  Caveats:
  - Wasteful of disk space if used on a non-extents based filing system (e.g. FAT32, ext3).
  It is best used in `/tmp` if possible. If you really must use a non-extents based filing
  system, destroy and recreate the object instance periodically to force resetting the lock
  file's length to zero.
  - Similarly older operating systems (e.g. Linux < 3.0) do not implement extent hole punching
  and therefore will also see excessive disk space consumption. Note at the time of writing
  OS X doesn't implement hole punching at all.
  - Byte range locks need to work properly on your system. Misconfiguring NFS or Samba
  to cause byte range locks to not work right will produce bad outcomes.
  - If your OS doesn't have sane byte range locks (OS X, BSD, older Linuxes) and multiple
  threads in your process use the same lock file, bad things will happen due to the lack
  of sanity in POSIX byte range locks. This may get fixed with a process-local byte range
  lock implementation if there is demand, otherwise simply don't use the same lock file
  from more than one thread on such systems.
  */

  class multiple_shared_lock
  {
    file_handle _h;

  public:
    multiple_shared_lock() {}
    multiple_shared_lock(const multiple_shared_lock &) = delete;
    multiple_shared_lock &operator=(const multiple_shared_lock &) = delete;
    multiple_shared_lock(multiple_shared_lock &&o) noexcept : _h(std::move(o._h)) {}
    multiple_shared_lock &operator=(multiple_shared_lock &&o) noexcept
    {
      _h = std::move(o._h);
      return *this;
    }

    static result<multiple_shared_lock> init(file_handle::path_type lockfile) noexcept {}

    void lock();
    bool try_lock();
    result<void> try_lock_timed(deadline d);
    void unlock();
  };

}  // namespace

BOOST_AFIO_V2_NAMESPACE_END


#endif
